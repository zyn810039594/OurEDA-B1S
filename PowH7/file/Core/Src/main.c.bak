/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under Ultimate Liberty license
 * SLA0044, the "License"; You may not use this file except in compliance with
 * the License. You may obtain a copy of the License at:
 *                             www.st.com/SLA0044
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
//#include "Sensor.h"
//#include "BasicCtrl.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
#ifdef CtrlSide
#define CabinNum 0
#define WaterNum 2
#endif

#ifdef PowerSide
#define CabinNum 1
#define WaterNum 4
#endif

#define MAX(a, b)			(a>b? a:b)
#define MIN(a, b)			(a<b? a:b)
#define RANGE(x, a, b)		(MIN(MAX(x, a), b))

//æ¥æ”¶æŒ‡é’ˆå®šä¹‰
u8 *PDString = 0;
//ä¸Šä¼ æŒ‡é’ˆå®šä¹‰
u8 *PUString = 0;

u8 *PDBegin = 0; 	//èµ·å§‹ä½ï¼Œåº”ä¸º0x25
u16 *PDStraight = 0; //å‰è¿›åé??
u16 *PDRotate = 0; 	//æ—‹è½¬ä¾§æ¨
u16 *PDVertical = 0; //å‚ç›´
u16 *PDLight = 0; 	//ç¯å…‰
u16 *PDTH = 0; 		//äº‘å°
u16 *PDTransp = 0; 	//ä¼ é??
u16 *PDArm[6] =
{ 0 }; 						//æœºæ¢°è‡?1-6
u16 *PDRes = 0; 		//é¢„ç•™PWM
u8 *PDMode = 0; 		//æ¨¡å¼å¼?å…?
u8 *PDId = 0; 		//éªŒè¯ä½?
u8 *PDEnd = 0; 		//ç»“æŸä½ï¼Œåº”ä¸º0x21

//èµ·å§‹ä½ï¼Œåº”ä¸º0x25
u8 *PUCabin = 0; 	//ä»“ä½
u16 *PUTemp = 0; 	//æ¸©åº¦
u16 *PUBaro[2] =
{ 0 }; 						//æ°”å‹
u16 *PUHum = 0; 		//æ¹¿åº¦
u16 *PUAcc[3] =
{ 0 }; 						//åŠ é?Ÿåº¦xã€yã€z
u16 *PURot[3] =
{ 0 }; 						//è§’é?Ÿåº¦xã€yã€z
u16 *PUEul[3] =
{ 0 }; 						//è§’åº¦Rollã€Pitchã€Yaw
u16 *PUMag[3] =
{ 0 }; 						//ç£åœºxã€yã€z
u16 *PUWaterT = 0; 			//æ°´æ¸©
u16 *PUWaterD = 0; 			//æ°´æ·±
u8 *PUId = 0; 					//ç¡®è®¤ä½?
//ç»“æŸä½ï¼Œåº”ä¸º0xFF

//ä¼ æ„Ÿå™¨IOè¯»å†™ä½æŒ‡é’?
volatile u8 *DeepSensorIO = 0; 		//æ·±åº¦ä¼ æ„Ÿå™¨è½¬å‘æ ‡å¿—ä½
volatile u8 *GY39SensorIO = 0; 		//æ¸©æ¹¿åº¦å’Œå¤§æ°”å‹ä¼ æ„Ÿå™¨è½¬å‘æ ‡å¿—ä½?
volatile u8 *WT931SensorIO = 0; 	//ä¹è½´ä¼ æ„Ÿå™¨è½¬å‘æ ‡å¿—ä½

u16 *DDepthPos; 					//æ°´æ·±æ•°æ®
u16 *DWaterTemperturePos; 			//æ°´æ¸©æ•°æ®

//WT931æŒ‡é’ˆ
u16 *PAccPos[3]; //åŠ é?Ÿåº¦xã€yã€z
u16 *PRotPos[3]; //è§’é?Ÿåº¦xã€yã€z
u16 *PEulPos[3]; //è§’åº¦xã€yã€z
u16 *PMagPos[3]; //ç£åœºxã€yã€z
u16 *PInsTemPos[4]; 									

//GY39æŒ‡é’ˆ
u16 *TTemPos; //æ¸©åº¦æ•°æ®
u16 *TBaroPos[2]; //æ°”å‹æ•°æ®
u16 *THumPos; //æ¹¿åº¦æ•°æ®

//æ°´æ·±åˆå§‹åŒ–å­—ç¬¦ä¸²
const u8 DSendStr[3]; //æ°´æ·±æ•°æ®

//GY39åˆå§‹åŒ–å­—ç¬¦ä¸²ï¼Œä¸è¦æ”¹åŠ?
//const u8 TInitStr[3] = { 0xA5, 0x83, 0x28 };
u8 TInitStr[3] = { 0xA5, 0x83, 0x28 };
//GY39è¯·æ±‚ä¸?æ¬¡æ¸©æ¹¿åº¦æ°”å‹å­—ç¬¦ä¸²ï¼Œä¸è¦æ”¹åŠ¨
const u8 TSendStr[3] = { 0xA5, 0x52, 0xF7 };
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

//ä¸Šä¼ ä¼ æ„Ÿå™¨ä»“ä½æ ‡å¿—ä½
volatile u8 SensorCabin = 0;

//ä¸Šä½æœºæ¥æ”¶å®Œæ¯•æ ‡å¿—ä½
volatile u8 UpSideFinish = 0;

//ä¸Šä½æœºç¼“å­˜è¯»å†™æ ‡å¿—ä½
volatile u8 UpIO = 0;

//ä¸Šä½æœºæ¥æ”¶ç¼“ï¿??
volatile u8 UpCache[UART3RXLen];

//ä¼ æ„Ÿå™¨è¯»å–å®Œæˆæ ‡å¿—ä½
volatile u8 WT931Finish = 0;
volatile u8 GY39Finish = 0;

//ä¼ æ„Ÿå™¨ç¼“å­˜è¯»å†™æ ‡å¿—ä½
volatile u8 WT931IO = 0;
volatile u8 GY39IO = 0;

//ä¼ æ„Ÿå™¨æ•°æ®é•¿ï¿??
volatile u8 WT931Len = 0;
volatile u8 GY39Len = 0;
//ä½œä¸šèµ·å§‹æ ‡å¿—ï¿??
volatile u8 DoingEnable = 0;

//ä¼ æ„Ÿå™¨ç¼“ï¿??
u8 WaterDetect = 0;
u16 AccelerationCache[3] =
{ 0 };
u16 RotSpeedCache[3] =
{ 0 };
u16 EulerAngleCache[3] =
{ 0 };
u16 MagnetisCache[3] =
{ 0 };

u16 TemCache = 0;
u16 BaroCache[2] =
{ 0 };
u16 HumCache = 0;

//ä¸²å£æ”¶å‘ç¼“å­˜
__attribute__((section(".RAM_D1")))                 u8 UART1RXCache[UART1RXLen] =
{ 0 };
__attribute__((section(".RAM_D1")))                 u8 UART1TXCache[UART1TXLen] =
{ 0 };
__attribute__((section(".RAM_D1")))                 u8 UART2RXCache[UART2RXLen] =
{ 0 };
__attribute__((section(".RAM_D1")))                 u8 UART3RXCache[UART3RXLen] =
{ 0 };
__attribute__((section(".RAM_D1")))                 u8 UART3TXCache[UART3TXLen] =
{ 0 };

//PWMç«¯å£å®šå‘æŒ‡é’ˆ
static u32 *ThrusterPWM[6] =
{ &TIM4->CCR1, &TIM4->CCR3, &TIM4->CCR2, &TIM4->CCR4, &TIM2->CCR4, &TIM2->CCR3 };
static u32 *ArmPWM[6] =
{ &TIM5->CCR4, &TIM5->CCR3, &TIM5->CCR2, &TIM3->CCR1, &TIM3->CCR4, &TIM3->CCR3 };
static u32 *LightPWM = &TIM2->CCR2;
static u32 *THPWM = &TIM2->CCR1;
static u32 *TranspPWM = &TIM5->CCR1;
static u32 *ReservePWM = &TIM3->CCR2;

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

IWDG_HandleTypeDef hiwdg1;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;
DMA_HandleTypeDef hdma_usart1_rx;
DMA_HandleTypeDef hdma_usart1_tx;
DMA_HandleTypeDef hdma_usart2_rx;
DMA_HandleTypeDef hdma_usart3_rx;
DMA_HandleTypeDef hdma_usart3_tx;

osThreadId InitialTaskHandle;
osThreadId SensorTaskHandle;
osThreadId UpTaskHandle;
osThreadId CtrlTaskHandle;
osThreadId EmptyTaskHandle;
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM3_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_IWDG1_Init(void);
void InitialTaskF(void const * argument);
void SensorTaskF(void const * argument);
void UpTaskF(void const * argument);
void CtrlTaskF(void const * argument);
void EmptyTaskF(void const * argument);

/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
//ä¸‹ä¼ æŒ‡ä»¤è¯»å–æ ¼å¼åŒ?
void DownDetectPoint(u8 *RXString)
{
	PDBegin = RXString; //èµ·å§‹ä½å¯¹å‡?
	/* å…¶ä»–å„ä½å¯¹é½ */
	PDStraight = (u16*) (RXString + 1);
	PDRotate = (u16*) (RXString + 3);
	PDVertical = (u16*) (RXString + 5);
	PDLight = (u16*) (RXString + 7);
	PDTH = (u16*) (RXString + 9);
	PDTransp = (u16*) (RXString + 11);
	PDArm[0] = (u16*) (RXString + 13);
	PDArm[1] = (u16*) (RXString + 15);
	PDArm[2] = (u16*) (RXString + 17);
	PDArm[3] = (u16*) (RXString + 19);
	PDArm[4] = (u16*) (RXString + 21);
	PDArm[5] = (u16*) (RXString + 23);
	PDRes = (u16*) (RXString + 25);
	PDMode = RXString + 27;
	PDId = RXString + 28;
	PDEnd = RXString + 29; //ç»“æŸä½å¯¹å‡?
}

/* ä¸‹ä¼ æ•°æ®è§£æ
 * ä»ä¸‹ä¼ æ•°æ®ä¸­è·å–æ§åˆ¶æ•°æ®
 * å¹¶ä¿å­˜åˆ°æ§åˆ¶æŒ‡é’ˆ
 * */
void DownDetectReceive(u16 *StraightNum, u16 *RotateNum, u16 *VerticalNum,
		u32 *LightNum, u32 *THNum, u32 *TranspNum, u32 *ArmNum[6], u32 *ResPWM,
		u8 *ModeNum, u8 *RelaySW)
{
#ifdef DataIdentify
	if (IdTest(PDString, 0)) //å¦‚æœå¼?å¯æ•°æ®æ ¡éªŒï¼Œåˆ™è‡ªåŠ¨å¯¹æ ¡éªŒä½è¿›è¡Œæ£€æµ?
	{
#endif
	if ((*PDBegin == 0x25) && (*PDEnd == 0x21)) //è¯†åˆ«èµ·å§‹å’Œç»“æŸä½
	{
		/* ä¿å­˜å„æ§åˆ¶ä½æ•°æ® */
		*StraightNum = *PDStraight;
		*RotateNum = *PDRotate;
		*VerticalNum = *PDVertical;
		*LightNum = *PDLight;
		*THNum = *PDTH;
		*TranspNum = *PDTransp;
		*ArmNum[0] = *PDArm[0];
		*ArmNum[1] = *PDArm[1];
		*ArmNum[2] = *PDArm[2];
		*ArmNum[3] = *PDArm[3];
		*ArmNum[4] = *PDArm[4];
		*ArmNum[5] = *PDArm[5];
		*ResPWM = *PDRes;
		*ModeNum = (*PDMode & 7);
		*RelaySW = (*PDMode & 8);
	}
#ifdef DataIdentify
	}
#endif

}

/* è¿åŠ¨æ¨¡å¼åˆ¤æ–­
 * ä¸»æ§åˆ¶ç«¯ä½¿ç”¨&6æ¨¡å¼ï¼Œæ¨è¿›å™¨æ§åˆ¶ç«¯ä½¿ç”?&4æ¨¡å¼
 * */
u8 DownMoveDetect(void)
{
#ifdef CtrlSide
	return *PDMode & 6;
#endif
#ifdef PowerSide
	return *PDMode & 4;
#endif
}

/* æœºå™¨äººæ­£å¸¸è¿åŠ¨å¤„ç†å‡½æ•?
 * ä½¿ç”¨ç»éªŒå…¬å¼è§£ç®—æ¨è¿›å™¨å‚æ•?
 * æœ?å¥½ä¸è¦ä¿®æ”¹è¿™éƒ¨åˆ†ä»£ç 
 * */
void MoveControl(u16 StraightNum, u16 RotateNum, u16 VerticalNum, u8 ModeNum,
		u32 *MoveThruster[6])
{
	if (ModeNum == 0)
	{
		u8 AFlag = (RotateNum > StraightNum);
		u8 BFlag = ((RotateNum + StraightNum) > 3000);
		u8 CFlag = (RotateNum > 1500);
		u8 DFlag = (StraightNum > 1500);
		u8 SFlag = AFlag * 8 + BFlag * 4 + CFlag * 2 + DFlag;
		switch (SFlag)
		{
		case 0:
		case 15:
			*MoveThruster[0] = (u32) (RotateNum);
			*MoveThruster[1] = (u32) (RotateNum);
			*MoveThruster[2] = (u32) ((1500 - RotateNum + StraightNum));
			*MoveThruster[3] = (u32) ((1500 - RotateNum + StraightNum));
			break;
		case 7:
		case 8:
			*MoveThruster[0] = (u32) (StraightNum);
			*MoveThruster[1] = (u32) (StraightNum);
			*MoveThruster[2] = (u32) ((1500 - RotateNum + StraightNum));
			*MoveThruster[3] = (u32) ((1500 - RotateNum + StraightNum));
			break;
		case 5:
		case 10:
			*MoveThruster[0] = (u32) ((RotateNum + StraightNum - 1500));
			*MoveThruster[1] = (u32) ((RotateNum + StraightNum - 1500));
			*MoveThruster[2] = (u32) (StraightNum);
			*MoveThruster[3] = (u32) (StraightNum);
			break;
		case 1:
		case 14:
			*MoveThruster[0] = (u32) ((RotateNum + StraightNum - 1500));
			*MoveThruster[1] = (u32) ((RotateNum + StraightNum - 1500));
			*MoveThruster[2] = (u32) ((3000 - RotateNum));
			*MoveThruster[3] = (u32) ((3000 - RotateNum));
			break;
		}
		*MoveThruster[4] = (u32) (VerticalNum);
		*MoveThruster[5] = (u32) (VerticalNum);
	}
	else if (ModeNum == 1)
	{
		*MoveThruster[0] = (u32) (*PDRotate);
		*MoveThruster[1] = (u32) ((3000 - *PDRotate));
		*MoveThruster[2] = (u32) (*PDRotate);
		*MoveThruster[3] = (u32) (3000 - *PDRotate);
		*MoveThruster[4] = (u32) (VerticalNum);
		*MoveThruster[5] = (u32) (VerticalNum);
	}
}

/* ç‰¹æ®Šè¿åŠ¨æ¨¡å¼å¤„ç†
 * ä½¿ç”¨PIDç®—æ³•å®ç°æœºå™¨äººè‡ªä¸»å®šå‘å®šæ·?
 * */
u16 SpecialMovePID(u8 ModeType, u16 SetValue, u16 ActualValue)
{
	//å½“å‰è¯¯å·®
	static float Ek;
	//å‰ä¸€æ¬¡è¯¯å·?
	static float Ek1;
	//ç´¯è®¡ç§¯åˆ†ä½ç½®
	static float LocSum;
	//æ•°æ®æ¸…ç©ºæ ‡å¿—ä½?
	static u8 PIDData = 0;

	if (ModeType == 4) //å®šå‘æ¨¡å¼
	{
		PIDData = 0;
		u16 PIDLoc;
		Ek = (float) (SetValue - ActualValue);
		LocSum += Ek;
		PIDLoc =
				(u16) (1500
						+ RANGE(
								(int16_t) (PID_D_Kp * Ek + (PID_D_Ki * LocSum) + PID_D_Kd * (Ek1 - Ek)),
								-1000, 1000));
		return PIDLoc;
	}
	else if (ModeType == 2) //å®šæ·±æ¨¡å¼
	{
		PIDData = 0;
		u16 PIDLoc;
		Ek = (float) (SetValue - ActualValue);
		LocSum += Ek;
		PIDLoc =
				(u16) (1500
						+ RANGE(
								(int16_t) (PID_O_Kp * Ek + (PID_O_Ki * LocSum) + PID_O_Kd * (Ek1 - Ek)),
								-1000, 1000));
		return PIDLoc;
	}
	else //ä¸ä½¿ç”¨è‡ªä¸»å®šå‘å®šæ·?
	{
		if (!PIDData)
		{
			PIDData = 1;
			Ek = 0;
			LocSum = 0;
		}
		return 0;
	}

}

/* ä¸Šä¼ æŒ‡é’ˆæ•°æ®æ ¼å¼åŒ?
 * å°†è¯»å–åˆ°çš„ä¼ æ„Ÿå™¨æ•°æ®åˆå¹¶
 * ç„¶åæ ¼å¼åŒ–æˆå¯ä»¥ä¸Šä¼ çš„åå…­è¿›åˆ¶æ•°æ?
 * å¹¶å°†æ ‡å¿—ä½æ³¨å†Œåˆ°åº“å†…
 * */
void SendBackPoint(u8 *TXString, u8 *DeepSIO, u8 *WT931SIO, u8 *GY39SIO)
{
	DeepSensorIO = DeepSIO; //æ·±åº¦ä¼ æ„Ÿå™¨æ•°æ®è½¬å‘æ ‡å¿—ä½
	WT931SensorIO = WT931SIO; //ä¹è½´ä¼ æ„Ÿå™¨æ•°æ®è½¬å‘æ ‡å¿—ä½
	GY39SensorIO = GY39SIO; //æ¸©æ¹¿åº¦æ°”å‹ä¼ æ„Ÿå™¨æ•°æ®è½¬å‘æ ‡å¿—ä½?

	TXString[0] = 0x25; //èµ·å§‹ä½?
	TXString[39] = 0xFF; //ç»“æŸä½?
	TXString[40] = 0xFF; //ç»“æŸä½?

	/* å°è£…æ•°æ® */
	PUString = TXString;
	PUCabin = TXString + 1;
	PUTemp = (u16*) (TXString + 2);
	PUBaro[0] = (u16*) (TXString + 4);
	PUBaro[1] = (u16*) (TXString + 6);
	PUHum = (u16*) (TXString + 8);
	PUAcc[0] = (u16*) (TXString + 10);
	PUAcc[1] = (u16*) (TXString + 12);
	PUAcc[2] = (u16*) (TXString + 14);
	PURot[0] = (u16*) (TXString + 16);
	PURot[1] = (u16*) (TXString + 18);
	PURot[2] = (u16*) (TXString + 20);
	PUEul[0] = (u16*) (TXString + 22);
	PUEul[1] = (u16*) (TXString + 24);
	PUEul[2] = (u16*) (TXString + 26);
	PUMag[0] = (u16*) (TXString + 28);
	PUMag[1] = (u16*) (TXString + 30);
	PUMag[2] = (u16*) (TXString + 32);
	PUWaterT = (u16*) (TXString + 34);
	PUWaterD = (u16*) (TXString + 36);
	PUId = TXString + 38;
	*PUId = XorCaculate(TXString, 38); //è·å–å¹¶å°è£…å¥‡å¶æ ¡éªŒä½
}

/* ä¸Šä¼ æŒ‡é’ˆæ•°æ®è§£æ
 * å°†å°è£…å¥½çš„ä¼ æ„Ÿå™¨æ•°æ®å†è§£ææˆèƒ½å¤Ÿå›ä¼ åˆ°ä¸Šä½æœºå’Œå…¶ä»–èˆ±å®¤çš„æ•°æ®
 * */
void SendBack(u8 WaterDetect, u16 TempNum, u16 BaroNum[2], u16 HumNum,
		u16 AccNum[3], u16 RotNum[3], u16 EulNum[3], u16 MagNum[3],
		u16 WaterTNum, u16 WaterDNum)
{
	*PUCabin = CabinNum; //ä»“ä½æ ‡å¿—ä½?

	if (WaterDetect) //æ¼æ°´æ£?æµ‹åˆ¤æ–­ä»“ä½?
	{
		*PUCabin += WaterNum;
	}
	if (!(*GY39SensorIO)) //æ¸©æ¹¿åº¦å¤§æ°”å‹ä¼ æ„Ÿå™¨è½¬å?
	{
		*PUTemp = TempNum;
		*PUBaro[0] = BaroNum[0];
		*PUBaro[1] = BaroNum[1];
		*PUHum = HumNum;
	}
	if (!(*WT931SensorIO)) //ä¹è½´ä¼ æ„Ÿå™¨è½¬å?
	{
		*PUAcc[0] = AccNum[0];
		*PUAcc[1] = AccNum[1];
		*PUAcc[2] = AccNum[2];
		*PURot[0] = RotNum[0];
		*PURot[1] = RotNum[1];
		*PURot[2] = RotNum[2];
		*PUEul[0] = EulNum[0];
		*PUEul[1] = EulNum[1];
		*PUEul[2] = EulNum[2];
		*PUMag[0] = MagNum[0];
		*PUMag[1] = MagNum[1];
		*PUMag[2] = MagNum[2];
	}
#ifdef CtrlSide
	//ä¸»æ§åˆ¶ä»“æœ‰æ°´æ·±ä¼ æ„Ÿå™¨ï¼Œéœ€è¦å…ˆæ£?æµ‹æ˜¯å¦æ­£å¸¸è¿æ?
	if (!(*DeepSensorIO)) //æ°´æ·±ä¼ æ„Ÿå™¨è½¬å?
	{
		*PUWaterT = WaterTNum;
		*PUWaterD = WaterDNum;
	}
#endif

#ifdef PowerSide
	//æ¨è¿›å™¨æ§åˆ¶ä»“æ²¡æœ‰æ°´æ·±ä¼ æ„Ÿå™?
	*PUWaterT = NULL;
	*PUWaterD = NULL;
#endif
	*PUId = XorCaculate(PUString, 38);
}

//å¼‚æˆ–è¿ç®—ä½æ£€æŸ¥ï¼Œå…¶ä¸­Formatä¸Šä¼ æ ¼å¼ä¸?1ä¸‹ä¼ æ ¼å¼ä¸?0ï¼Œæ­£ç¡®ä¸º1é”™è¯¯ä¸?0
u8 IdTest(u8 *String, u8 Format)
{
#ifdef DataIdentify
	if (Format)
	{
		if (*(String + 38) == XorCaculate(String, 38))
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
	else
	{
		if (*(String + 28) == XorCaculate(String, 28))
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
#endif
	return 1;
}

//å¼‚æˆ–è¿ç®—ä½è®¡ç®?
u8 XorCaculate(u8 *CacString, u8 CacStringSize)
{
	u8 CacResult = CacString[0];
	for (u8 i = 0; i < CacStringSize; ++i)
	{
		CacResult ^= CacString[i];
	}
	return CacResult;
}







//æ°´æ·±æ•°æ®æŒ‡é’ˆå®šå‘
void DeepPoint(u8 *SerialData)
{
	DDepthPos = (u16*) (SerialData);
	DWaterTemperturePos = (u16*) (SerialData + 2);
}

////æ°´æ·±æ•°æ®è¯·æ±‚
//void DeepRequestStr(u8 *TXCache)
//{
//
//}

//æ°´æ·±æ•°æ®è¾“å‡º
void DeepTake(u16 *DepthNum, u16 *WaterTempertureNum)
{
	*DepthNum = *DDepthPos;
	*WaterTempertureNum = *DWaterTemperturePos;
}

//WT931æ•°æ®æŒ‡é’ˆå®šå‘
void WT931Point(u8 *SerialData)
{
	PAccPos[0] = (u16*) (SerialData + 2);
	PAccPos[1] = (u16*) (SerialData + 4);
	PAccPos[2] = (u16*) (SerialData + 6);
	PInsTemPos[0] = (u16*) (SerialData + 8);
	PRotPos[0] = (u16*) (SerialData + 13);
	PRotPos[1] = (u16*) (SerialData + 15);
	PRotPos[2] = (u16*) (SerialData + 17);
	PInsTemPos[1] = (u16*) (SerialData + 19);
	PEulPos[0] = (u16*) (SerialData + 24);
	PEulPos[1] = (u16*) (SerialData + 26);
	PEulPos[2] = (u16*) (SerialData + 28);
	PInsTemPos[2] = (u16*) (SerialData + 30);
	PMagPos[0] = (u16*) (SerialData + 35);
	PMagPos[1] = (u16*) (SerialData + 37);
	PMagPos[2] = (u16*) (SerialData + 39);
	PInsTemPos[2] = (u16*) (SerialData + 41);
	/*
	PAccPos[0] = (u16*)SerialData + 2;
	PAccPos[1] = (u16*)SerialData + 4;
	PAccPos[2] = (u16*)SerialData + 6;
	PInsTemPos[0] = (u16*)SerialData + 8;
	PRotPos[0] = (u16*)SerialData + 13;
	PRotPos[1] = (u16*)SerialData + 15;
	PRotPos[2] = (u16*)SerialData + 17;
	PInsTemPos[1] = (u16*)SerialData + 19;
	PEulPos[0] = (u16*) (SerialData + 24);
	PEulPos[1] = (u16*) (SerialData + 26);
	PEulPos[2] = (u16*) (SerialData + 28);
	PInsTemPos[2] = (u16*) (SerialData + 30);
	PMagPos[0] = (u16*) (SerialData + 35);
	PMagPos[1] = (u16*) (SerialData + 37);
	PMagPos[2] = (u16*) (SerialData + 39);
	PInsTemPos[2] = (u16*) (SerialData + 41);
	*/
}

//WT931æ•°æ®å–å‡º
void WT931Take(u16 *AccelerationNum, u16 *RotSpeedNum, u16 *EulerAngleNum,
		u16 *MagnetismNum)
{
	AccelerationNum[0] = *PAccPos[0];
	AccelerationNum[1] = *PAccPos[1];
	AccelerationNum[2] = *PAccPos[2];
	RotSpeedNum[0] = *PRotPos[0];
	RotSpeedNum[1] = *PRotPos[1];
	RotSpeedNum[2] = *PRotPos[2];
	EulerAngleNum[0] = *PEulPos[0];
	EulerAngleNum[1] = *PEulPos[1];
	EulerAngleNum[2] = *PEulPos[2];
	MagnetismNum[0] = *PMagPos[0];
	MagnetismNum[1] = *PMagPos[1];
	MagnetismNum[2] = *PMagPos[2];
}

//è¯»å–GY39åˆå§‹åŒ–æŒ‡ä»?
//æ³¨æ„ï¼šè¯¥å‡½æ•°æœ‰é”™è¯?
void GY39InitStr(u8 TXCache[3])
{
	TXCache[0] = TInitStr[0];
	TXCache[1] = TInitStr[1];
	TXCache[2] = TInitStr[1];
}


////è¯»å–GY39è¯·æ±‚æŒ‡ä»¤
//void GY39RequestStr(u8 TXCache[3])
//{
//	TXCache[0]=TSendStr[0];
//	TXCache[1]=TSendStr[1];
//	TXCache[2]=TSendStr[2];
//}

//GY39æ•°æ®æŒ‡é’ˆå®šå‘
void GY39Point(u8 *SerialData)
{
	TTemPos = (u16*) (SerialData + 13);
	TBaroPos[0] = (u16*) (SerialData + 15);
	TBaroPos[1] = (u16*) (SerialData + 17);
	THumPos = (u16*) (SerialData + 19);
}

//GY39æ•°æ®è¾“å‡º
void GY39Take(u16 *TemNum, u16 BaroNum[2], u16 *HumNum)
{
	*TemNum = *TTemPos;
	BaroNum[0] = *TBaroPos[0];
	BaroNum[1] = *TBaroPos[1];
	*HumNum = *THumPos;
}







/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_TIM4_Init();
  MX_TIM5_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  MX_IWDG1_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
	/* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
	/* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of InitialTask */
  osThreadDef(InitialTask, InitialTaskF, osPriorityRealtime, 0, 512);
  InitialTaskHandle = osThreadCreate(osThread(InitialTask), NULL);

  /* definition and creation of SensorTask */
  osThreadDef(SensorTask, SensorTaskF, osPriorityNormal, 0, 512);
  SensorTaskHandle = osThreadCreate(osThread(SensorTask), NULL);

  /* definition and creation of UpTask */
  osThreadDef(UpTask, UpTaskF, osPriorityNormal, 0, 512);
  UpTaskHandle = osThreadCreate(osThread(UpTask), NULL);

  /* definition and creation of CtrlTask */
  osThreadDef(CtrlTask, CtrlTaskF, osPriorityNormal, 0, 512);
  CtrlTaskHandle = osThreadCreate(osThread(CtrlTask), NULL);

  /* definition and creation of EmptyTask */
  osThreadDef(EmptyTask, EmptyTaskF, osPriorityIdle, 0, 512);
  EmptyTaskHandle = osThreadCreate(osThread(EmptyTask), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
	/* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
	while (1)
	{
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	}
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 5;
  RCC_OscInitStruct.PLL.PLLN = 160;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
                              |RCC_PERIPHCLK_USART3;
  PeriphClkInitStruct.PLL3.PLL3M = 25;
  PeriphClkInitStruct.PLL3.PLL3N = 192;
  PeriphClkInitStruct.PLL3.PLL3P = 2;
  PeriphClkInitStruct.PLL3.PLL3Q = 2;
  PeriphClkInitStruct.PLL3.PLL3R = 2;
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
  PeriphClkInitStruct.PLL3.PLL3VCOSEL = RCC_PLL3VCOWIDE;
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
  PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_PLL3;
  PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_PLL3;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief IWDG1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_IWDG1_Init(void)
{

  /* USER CODE BEGIN IWDG1_Init 0 */

  /* USER CODE END IWDG1_Init 0 */

  /* USER CODE BEGIN IWDG1_Init 1 */

  /* USER CODE END IWDG1_Init 1 */
  hiwdg1.Instance = IWDG1;
  hiwdg1.Init.Prescaler = IWDG_PRESCALER_4;
  hiwdg1.Init.Window = 2047;
  hiwdg1.Init.Reload = 2047;
  if (HAL_IWDG_Init(&hiwdg1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN IWDG1_Init 2 */

  /* USER CODE END IWDG1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 200-1;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 50000-1;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 200-1;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 50000-1;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 199;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 50000-1;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */
  HAL_TIM_MspPostInit(&htim4);

}

/**
  * @brief TIM5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM5_Init(void)
{

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  htim5.Init.Prescaler = 199;
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 50000-1;
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 1500;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */
  HAL_TIM_MspPostInit(&htim5);

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 921600;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 6, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 6, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 6, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
  /* DMA1_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 6, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn);
  /* DMA1_Stream5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 6, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_RESET);

  /*Configure GPIO pin : PD10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*Configure GPIO pin : PD11 */
  GPIO_InitStruct.Pin = GPIO_PIN_11;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/* USER CODE BEGIN Header_InitialTaskF */
/**
 * @brief  Function implementing the InitialTask thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_InitialTaskF */
void InitialTaskF(void const * argument)
{
  /* USER CODE BEGIN 5 */
	//æŒ‚èµ·è¦æ‰§è¡Œçš„ä»»åŠ¡
	vTaskSuspend(SensorTaskHandle);
	vTaskSuspend(UpTaskHandle);
	vTaskSuspend(CtrlTaskHandle);
	//ç»§ç”µå™¨æ‰“ï¿??
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, GPIO_PIN_RESET);
	//åˆå§‹åŒ–ä¸‹ä¼ æ•°æ®æ¥æ”¶ç¼“ï¿??
	DownDetectPoint(UpCache);
	/* åˆå§‹åŒ–ä¸€å¤§å †PWM */
	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_4);

	__HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart3, UART3RXCache, UART3RXLen);
	__HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart1, UART1RXCache, UART1RXLen);
	__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart2, UART2RXCache, UART2RXLen);
	osDelay(100);
	UpSideFinish = 0;
	GY39Finish = 0;
	WT931Finish = 0;
	__HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart3, UART3RXCache, UART3RXLen);
	__HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart1, UART1RXCache, UART1RXLen);
	__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
	HAL_UART_Receive_DMA(&huart2, UART2RXCache, UART2RXLen);

	//ï¿??å¯å…¶ä»–ä»»ï¿??
	vTaskResume(UpTaskHandle);
	vTaskResume(SensorTaskHandle);
	vTaskResume(CtrlTaskHandle);
	//å–‚ç‹—
	HAL_IWDG_Refresh(&hiwdg1);
	//æŒ‚èµ·åˆå§‹åŒ–ä»»åŠ¡ä¸å†æ‰§ï¿??
	vTaskSuspend(InitialTaskHandle);
	/* Infinite loop */
	for (;;)
	{
		osDelay(1);
	}
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_SensorTaskF */
/**
 * @brief Function implementing the SensorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_SensorTaskF */
void SensorTaskF(void const * argument)
{
  /* USER CODE BEGIN SensorTaskF */
	WT931Point(UART2RXCache);
	GY39InitStr(UART1TXCache);
	HAL_UART_Transmit_DMA(&huart1, UART1TXCache, UART1TXLen);
	GY39Point(UART1RXCache);
	/* Infinite loop */
	for (;;)
	{
		WaterDetect = HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_10);
		if (WT931Finish)
		{
			while (WT931IO)
			{
				osDelay(1);
			}
			WT931IO = 1;
			if (WT931Len == 44)
			{
				WT931Take(AccelerationCache, RotSpeedCache, EulerAngleCache,
						MagnetisCache);
			}
			WT931Finish = 0;
			HAL_UART_Receive_DMA(&huart2, UART2RXCache, UART2RXLen);
			__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
			WT931IO = 0;
		}
		
		if (GY39Finish)
		{
			while (GY39IO)
			{
				osDelay(1);
			}
			GY39IO = 1;
			GY39Take(&TemCache, BaroCache, &HumCache);
			GY39Finish = 0;
			HAL_UART_Receive_DMA(&huart1, UART1RXCache, UART1RXLen);
			__HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
			GY39IO = 0;
		}
		HAL_IWDG_Refresh(&hiwdg1);
	}
  /* USER CODE END SensorTaskF */
}

/* USER CODE BEGIN Header_UpTaskF */
/**
 * @brief Function implementing the UpTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_UpTaskF */
void UpTaskF(void const * argument)
{
  /* USER CODE BEGIN UpTaskF */
	//åˆå§‹åŒ–å›ä¼ æŒ‡ï¿??
	SendBackPoint(UART3TXCache, NULL, &WT931IO, &GY39IO);
	vTaskDelete(InitialTaskHandle);
	/* Infinite loop */
	for (;;)
	{
		while (!UpSideFinish)
		{
			osDelay(1);
		}
		UpSideFinish = 0;
		
#ifdef DataIdentify
		if (IdTest(UART3RXCache, 0))
		{
#endif
		while (UpIO)
		{
			osDelay(1);
		}
		UpIO = 1;
		
		for (u8 i = 0; i < UART3RXLen; ++i)
		{
			UpCache[i] = UART3RXCache[i];
		}
		UpIO = 0;
#ifdef DataIdentify
		}
#endif
		DoingEnable = 1;
		__HAL_UART_ENABLE_IT(&huart3, UART_IT_IDLE);
		HAL_UART_Receive_DMA(&huart3, UART3RXCache, UART3RXLen);
		SendBack(WaterDetect, TemCache, BaroCache, HumCache, AccelerationCache,
				RotSpeedCache, EulerAngleCache, MagnetisCache, NULL, NULL);
		HAL_UART_Transmit_DMA(&huart3, UART3TXCache, UART3TXLen);
		HAL_IWDG_Refresh(&hiwdg1);
	}
  /* USER CODE END UpTaskF */
}

/* USER CODE BEGIN Header_CtrlTaskF */
/**
 * @brief Function implementing the CtrlTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_CtrlTaskF */
void CtrlTaskF(void const * argument)
{
  /* USER CODE BEGIN CtrlTaskF */
//	static u16 RStraightNum = 0;
//	static u16 RRotateNum = 0;
//	static u16 RVerticalNum = 0;
//	static u8 RMode = 0;
//	static u8 RRelay = 0;

//	while (!DoingEnable)
//	{
//		osDelay(1);
//	}

	/* Infinite loop */
	for (;;)
	{
//		while (UpIO)
//		{
//			osDelay(1);
//		}
//		UpIO = 1;
//		/* æ¥æ”¶å¹¶å¤„ç†ä¸‹ä¼ æ•°ï¿?? */
//		DownDetectReceive(&RStraightNum, &RRotateNum, &RVerticalNum, LightPWM,
//				THPWM, TranspPWM, ArmPWM, ReservePWM, &RMode, &RRelay);

//		UpIO = 0;
//		//æ§åˆ¶ç»§ç”µï¿??
//		HAL_GPIO_WritePin(GPIOD, GPIO_PIN_11, RRelay);
//		//é€šè¿‡æ§åˆ¶PWMæ“ä½œæ¨è¿›å™¨æ¥å¤„ç†æœºå™¨äººè¿ï¿??
//		MoveControl(RStraightNum, RRotateNum, RVerticalNum, RMode, ThrusterPWM);
		HAL_IWDG_Refresh(&hiwdg1);
		osDelay(1);
	}
  /* USER CODE END CtrlTaskF */
}

/* USER CODE BEGIN Header_EmptyTaskF */
/**
 * @brief Function implementing the EmptyTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_EmptyTaskF */
void EmptyTaskF(void const * argument)
{
  /* USER CODE BEGIN EmptyTaskF */
	/* Infinite loop */
	for (;;)
	{
		HAL_IWDG_Refresh(&hiwdg1); //å–‚ç‹—
	}
  /* USER CODE END EmptyTaskF */
}

 /**
  * @brief  Period elapsed callback in non blocking mode
  * @note   This function is called  when TIM6 interrupt took place, inside
  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
